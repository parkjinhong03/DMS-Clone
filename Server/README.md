# **DSM-Backend Task** (Clone DSM api)

## 1. **Language**

- **python**

    > 가독성이 뛰어나고, 넓은 확장성을 가지고 있기 때문에 **Python**으로 개발을 하기 시작하였습니다.

<br>

## 2. **Framwork**
- **flask**
    > Python의 대표적인 마이크로 프레임워크 중 하나로, **서버의 기본 개념**을 잡기 위해 처음으로 배우고 사용하는 프레임워크입니다.

<br>

## 3. **Database**
- **Local directorys & files!**
    > 여러 정보들을 **폴더에 체계적**으로 담아서 관리했습니다. DB와 연동하지 않은 이유는, **아직 local 말고 DB에 저장해서 관리해야 할 필요성**을 느끼지 못했기 때문입니다.

<br>

## 4. **세부적인 사항**
- **status_code**
    > 클라이언트에서 데이터가 잘 처리됬는지, 아니면 어느 부분에서 오류가 발생했는지 알 수 있도록 **status_code**를 설정해서 반환합니다.

- **파일 모듈화**
    > 뛰어난 가독성과 유지보수의 편리함을 위해 **각 api 모듈들을 파일로 세분화** 해서 정리했습니다. 또한 **회원 정보 관련 api는 auth** 디렉토리에, 그 밖의 **여러 기능 api들을 service** 디렉토리에 담았습니다.  

- **add_url_rule**
    > 앞서 말씀드렸던 것 처럼, api를 모듈화해서 담으면 **run.py에서 그 api를 라우팅**을 해줘야 하는데, 그러기 위해서 app의 **add_url_urle 메소드**를 사용해 줬습니다.

- **쿠키의 사용**
    > **현재 사용자의 상태**(로그인 여부, 로그인한 유저 id)를 식별하기 위해 cookie를 저장하여 클라이언트가 request를 보낼 때 마다 쿠키의 값을 같이 보내여, 서버에서 **그 쿠키의 값으로 회원 정보를 판단**할 수 있게 하였습니다.

- **http POST 메소드**
    > 클라이언트에서 값을 보낼 때, 그 값을 **POST 형식** 으로 보냈을 때에만 서버가 값을 전송받을 수 있게 하였습니다. GET으로 요청할 시, **url에 param**이 그대로 붙여져서 가므로, **보안의 취약점** 때문에 그렇게 하였습니다.

- **Body - form**
    > 클라이언트에서 http 요청을 보낼 시, 그 **HTTP의 Body값을 form 형태**일 시, 받도록 하였습니다. 그 이유는 예전에 html에 대해 공부했을 때 값을 전송할 때 form 태그를 이용했기 때문에 서버에서도 form 형식으로 받아야된다고 생각을 했기 때문입니다.

    > 이 부분에 대해서는 더 공부를 해서 **상황에 맞는 형식**으로 값을 받아서 처리하도록 할 것 입니다.

-  **return Dict**
    > 기상 음악 신청 조회나 잔류 신청 조회 api시, 요청을 보낸 클라이언트에 데이터를 response해 줘야 하는데, 그 때 **반환할 데이터의 타입**을 클라이언트에서 **데이터를 파싱하기 쉬운 Dict**로 설정했습니다.

- **JSON 포맷팅**
    > open('파일경로')로 파일을 열고 dict 타입의 데이터를 작성 시, 오류가 나는 것을 확인할 수 있습니다. 따라서 **문자열로 처리**를 해야 하는데, 그러기 위해 **json의 dumps 모듈**을 사용하여 저장하고, 꺼내 쓸 때 **loads 모듈로 다시 dict 타입으로 변환**하여 사용할 수 있도록 하였습니다.

<br>

---
여기까지 저가 이번에 DMS-backend 과제를 하며 사용했던 **기술 스택이나 방식**이였습니다.  

봐주셔서 감사드리고, 열심히 한 만큼 좋은 결과가 있기를 바랍니다!!